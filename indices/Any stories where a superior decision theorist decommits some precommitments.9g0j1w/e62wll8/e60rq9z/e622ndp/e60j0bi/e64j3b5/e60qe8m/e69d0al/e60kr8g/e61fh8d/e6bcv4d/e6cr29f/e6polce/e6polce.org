:PROPERTIES:
:Author: MultipartiteMind
:Score: 1
:DateUnix: 1538018298.0
:DateShort: 2018-Sep-27
:END:

(The 'on a case by case basis' is worrying in regards to whether something could be treated as a correct prediction rather than a coincidentally-true random statement; deadlines sound good!) Might there be a convenient way--blockchain incorporation?--to prove/set-in-rock dates of cyphered revelation, claimed deadline (both the deadline itself and the date on which claimed), and uncyphered revelation? --Even then, though, there's the issue of someone making lots of hidden claims that no one can see or know about, then unhiding coincidentally-true ones and saying "Look! You all remember back when I shared this cyphertext, don't you? See how it satisfies the deadline exactly!" Ah, but (systems in which such hiding and unhiding for a single identity is impossible aside) perhaps that could be dealt with by people only giving credence to cyphertexts and deadlines which they themselves saw and locally recorded at time of publishing..? Potentially problematic in the burden put on people to aggregatedly record lots of untrusted claims, else being unable for their claimers to ever start accruing trust? Perhaps if there were a few aggregation companies/organisations, working with large numbers of claimers to record, check, and laud-where-notable claimers, with each claim and deadline available for local saving, such that others can rely on the corruptible process to get an idea of what others view as trustworthy, then locally follow for verification to stop corruption... as long as the deadline reminders are local too, and aren't from an outside organisation... there could still be corruption, granted, in that such organisations could just not laud or stop lauding certain claimers if the claimers' positions (especially if consistently correct) were inconvenient for the organisations' backers. There's also the risk, unless each each lauded claimer's claims and deadlines are stored from the claimer's own site rather than the aggregation site, of a man-in-the-middle falsification of a claimer's claim, though catchable if anyone who would have been fooled checked the cyphertext on the two sites against each other when locally storing (which in any case requires the option of storing from the claimer's own site). Hmm.

​

("Equivalently, flipping any non-zero number of bits in an input will statistically result in 50% of the output bits also being flipped.": This sentence makes me happy.)

​

Current impression: upon a decryption deadline, rather than give a reader a key and let them decrypt cyphertext to get the input, one gives the reader the input (and a key, or otherwise making sure they already had the encryption function--presumably a key necessary, else short cyphertexts could be brute-forced by guessing plausible short sentences, particularly if the claimer's specialty is known?), and let's them check that the provided input gives the same hash as previously shown. As such, the 'cyphertext/hash' can have less information complexity than the input? (Edit: Or was 2.'s "You can't recover the input from the output" intended to mean "...without actually running the decryption function" as in 1.? )

​

(*reads a little about public and private keys* ...if one can have two arbitrary entities which want to privately communicate using each other's public keys with their own private keys and never having any sharing-private-key moment of potential interception, this is astoundingly reassuring... O.O (Other than of course the [[https://xkcd.com/538/][xkcd.com/538/]] approach and its issue of being able to follow back where signals are coming from--particularly if assuming that some utterances normally have to be readable by everyone, for conversations/trades to start in the first place.))