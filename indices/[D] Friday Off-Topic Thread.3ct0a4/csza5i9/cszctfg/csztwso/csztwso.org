:PROPERTIES:
:Score: 5
:DateUnix: 1436634806.0
:DateShort: 2015-Jul-11
:END:

Ok, so.... you've heard of the Halting Problem, right? [[http://www.scottaaronson.com/blog/?p=710][Well the Halting Problem is the reason that proof systems can't self-verify.]] As Aarsonson shows, for a proof system to prove itself sound and consistent would actually involve formally demonstrating, in finite time, that it "knows" exactly which Turing machines halt and don't halt, which is exactly what the Halting Problem says can't be done in finite time.

This is because verifying that every provable statement is actually true involves proving some statements which are formally encodings of, "So-and-so computer program doesn't halt, it loops forever." But /formal/ proof, by definition, involves a finite axiom schema (set of rules for starting with) and a finite number of proof-steps.

You might think that, hey, lots of infinite loops can easily be detected by /looking at the code/, so why is this a problem? Then, after all, you showed that the program doesn't halt in a finite number of proof steps (those involved in formally writing out, "I looked at it and /here/ is the loop"). But you've only got a finite axiom schema, which means your formal system only knows a finite number of ways for things to provably loop forever. But I can also write out all the axioms in your finite axiom schema, look at /those/, and construct an infinite loop that's /more complicated than them/, and which your axiom schema thus cannot detect (this method of proving something is "too large" to be described in a certain-sized set of rules is called [[https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument]["diagonalization"]]). So actually, you can't write a finite piece of code that can "see" /all/ the infinite loops -- that would require an /infinite/ axiom schema (and where would we get that from?).

Soooo... the advance Calude made was to provide an actual algorithm by which we can say, "Well, we ran the program for a /really fucking long time/ and it /still/ hasn't stopped, so we estimate a 1-p /probability/ that it's just never going to stop." This sounds quite intuitive, but actually takes a whole lot of formal machinery to demonstrate that I don't entirely understand yet due to playing catch-up on my math knowledge.

However, armed with such an algorithm, we can start doing interesting things to it. For instance, in programming languages theory (which is what this is, mostly), we have /total/ languages (in which all programs are required to halt on all inputs), and we have /partial/ languages (in which some programs can loop forever). The kinds of type systems used in languages like ML or Haskell can, when applied to a /total/ language, be used to build proof assistants based on [[https://en.wikipedia.org/wiki/Type_theory][type theory]] -- since every program halts, every program /proves something/. In "real" languages, we instead have to talk about [[https://en.wikipedia.org/wiki/Domain_theory][domain theory]], which is basically about sets and types that might contain a special element for "loops forever".

Notably, one of the very specific things you /can't/ write in a total, typed language is the evaluator/interpreter /for that language/. Even though it's a total language, and every program /will/ terminate, it will be impossible to prove at the type-system level that the evaluator/interpreter terminates. That self-referencing proof is "too large" for the finite axiom schema the language already has.

But with [[https://researchspace.auckland.ac.nz/handle/2292/23906][Calude's algorithm]], we get around that by saying, "Hey, if it /does/ terminate, we'll find out eventually just by running it long enough. And if we didn't run it for long enough, we'll get a well-defined /probability/ so that we can hedge our bets rather than just guessing and getting it wrong." This means we should be able to build probabilistic termination checkers. Since Calude's algorithm /segregates/ halting from nonhalting behavior, we should also be able to use it to "lift" results from domains into types: we run a program that has been verified to have a domain (ie: it might return a =T=, or it might loop forever) for a long time, and then we get a well-defined distribution at the end over both the set of possible values in type =T= /and/ infinite looping, which we can then lift to the /type/ =P(T \/ False)=.

Since we'll have a probabilistic termination checker, we'll also be able to write a language that puts a sound probability on the correctness of its own interpreter.

But this is all going to take a lot of further reading and work. We're not exactly coding anything soon, and it could all turn out to be wrong (because there's actually only a very small new idea here, which requires a lot of text to explain to a layperson).